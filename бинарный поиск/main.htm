<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="../подсветка/styles/default.min.css">
    <title>Бинарный поиск</title>
</head>
<body>
    <header class="header">
        <a href="../index.htm" class="return">Назад</a>
        <div class="topic">Бинарный поиск</div>
    </header>
    <div class="container">
        <section class="about_topic">
            <h1>Определение</h1>
            <p>Пусть задана монотонная (возрастающая или убывающая) функция f(x), а также некоторое значение y. Бинарный, или двоичный, поиск - алгоритм, позволяющий за время O(logN) найти такое значение x, что f(x)=y.</p>
            <p>Часто вместо математической функции f(x) бинарный поиск производится на отсортированных по возрастанию или убыванию массивах. Если массив не содержит искомого элемента, алгоритм найдёт ближайший к нему элемент (или, более точно, позицию в массиве, на которую нужно вставить искомый элемент, чтобы сохранить упорядоченность).</p>
            <h1>Описание алгоритма</h1>
            <p>Бинарный поиск - один из самых простых и полезных алгоритмов. Его идея заключается в поддерживании некоторого промежутка значений x, который точно содержит искомое значение, и постепенном его сужении до одного элемента (в случае поиска по массиву) или допустимой погрешности (в случае поиска по непрерывной функции).</p>
            <p>Предположим, что наша функция возрастает, и текущие границы промежутка, точно содержащего x, это [l;r]. Сужение выполняется следующим образом: возьмём “среднюю” точку в промежутке m=(l+r)/2, и сравним f(m) с y:</p>
            <p>1) Если f(m) < y, то для всех x < m правда, что f(x) ≤ f(m) < y. То есть промежуток [l;m) нас не интересует: x точно находится в [m;r]. </p>
            <p>2) Если f(m)>y, то по такой же логике промежуток (m;r] нас не интересует, можем сузить диапазон поиска до [l;m].</p>
            <p>3) Если f(m)=y, то мы нашли искомое значение: x=m.</p>
            <p>После каждого шага мы либо находим ответ, либо сужаем диапазон поиска в два раза. В случае поиска по непрерывной функции в какой-то момент длина отрезка [l;r] станет меньше допустимой погрешности (например, 10−6), и любой из концов отрезка можно считать ответом. В случае поиска по массиву (где l и r должны быть целыми числами), в какой-то момент станет так, что l=r=x, где x - индекс элемента y, если он присутствует в массиве, или позиция в массиве, на которую можно вставить y, не нарушая порядка сортировки.</p>
            <p>Если функция не возрастает, а убывает, алгоритм выглядит практически так же, но логика при сужениях обратная: если f(m) < y, то откидываем правую половину, и наоборот.</p>
            <h1>Задача</h1>
            <p>Дан отсортированный массив. Нужно найти за наименьшее время найти число x. </p>
            <h1>Решение</h1>
            <p>Будем использовать бинпоиск</p>
            <pre>
                <code data-lang="cpp">
                    #include &lt;iostream&gt;

                    using namespace std;

                    int main()
                    {
                        int arr[10] = {17, 20, 26, 31, 44, 54, 55, 65, 77, 93};
                        int x;
                        cin >> x;
                        
                        int l = 0, r = 9;
                        while(l+1 < r)
                        {
                            int mid = (r+l)/2;
                            if(arr[mid] < x) // Т.к тут строгое неравенство, то ответ будет лежать в r
                            {
                                l = mid;
                            }else{
                                r = mid;
                            }
                        }
                        if(arr[r] == x)
                            cout << "Index of number: " << r;
                        else
                            cout << "there is no this number";
                        return 0;
                    }
                </code>
            </pre>
            <p>Давайте найдем число 54. Программа выведет 5 и это верно. По следующим рисункам вы сможете увидеть работу алгоритма.</p>
            <img src="images/Бинпоиск1.png" alt="" class = "img">
            <img src="images/Бинпоиск2.png" alt="" class = "img">
            <img src="images/Бинпоиск3.png" alt="" class = "img">
            <img src="images/Бинпоиск4.png" alt="" class = "img">
            <h1>Заключение</h1>
            <p>Теперь вы можете быстро искать данные в упорядоченном массиве. Алгоритм работает только на монотонных функциях.</p>
        </section>
    </div>
    <script src="../подсветка/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
