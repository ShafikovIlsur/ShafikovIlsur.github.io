<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="../подсветка/styles/default.min.css">
    <title>Графы</title>
</head>
<body>
    <header class="header">
        <a href="file:///C:/Users/admin/Documents/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%209%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA%20%D1%82%D0%B5%D0%BC/index.htm" class="return">Назад</a>
        <div class="topic">Графы</div>
    </header>
    <div class="container">
        <section class="about_topic">
            <h1>Определение</h1>
            <p>Графом называется пара множеств G = (V, E), где множество V называется множеством вершин графа, а множество E, состоящее из пар вершин (u, v), называется множеством ребер графа.</p>
            <p>Если существует ребро (u, v), то говорят что оно соединяет вершины u и v. Две вершины, соединенные ребром, называют смежными. Для вершины vv любое ребро (v, u) называется инцидентным ей. Число ребер, инцидентных вершине v, называют степенью вершины v.</p>
            <p>Если какие-то две вершины соединены более, чем одним ребром, то говорят, что граф содержит кратное ребро. Если ребро соединяет вершину саму с собой, то такое ребро называют петлей. Если граф не содержит петель и кратных ребер, то он называется простым.</p>
            <p>Примеры графов:</p>
            <img src="images/graphs.png" alt="" class = "img" width="700">
            <p>Граф называют ориентированным, если для каждого ребра задано направление, и неориентированным в противном случае. Для ребра (u, v) обратным ребром называется ребро (v, u). Неориентированные графы часто рассматривают как ориентированные, добавив вместо каждого ребра два для каждого направления.</p>
            <p>Путем называется последовательность вершин, соединенных между собой ребрами. Если в пути не повторяются вершины, он называется простым. Из вершины v достижима вершина u, если существует путь, начинающийся в v и заканчивающийся в u. Если от каждой вершины достижима любая другая, граф называется связным.</p>
            <p>Циклом называется путь, начинающийся и заканчивающийся в одной и той же вершине. Если помимо первой и последней вершины все остальные вершины на этой пути уникальны, то такой цикл называется простым. Граф называют ацикличным, если в нем нет простых циклов.</p>
            <p>Ацикличный неориентированный граф называется лесом. Связный лес называется деревом. У деревьев есть другие эквивалентные определения:</p>
            <p>1) Граф является деревом, если в нем n вершин и (n-1) ребер и нет циклов.</p>
            <p>2) Граф является деревом, если из любой вершины можно дойти в любую другую единственным образом.</p>
            <p>Если дерево называется корневым, если у него есть ровно одна специальная вершина, называемая корнем. Часто подразумевается, что ребра корневого дерева ориентированы так, что от корня можно дойти от всех остальных вершин.</p>
            <p>Граф называется планарным, если его можно разложить на плоскости так, чтобы его ребра не пересекались в точках, отличных от вершин. Граф называется двудольным, если его вершины которого можно разделить на два множества таких, что ребра соединяют только вершины из разных множеств.</p>
            <h1>Способы хранения</h1>
            <p>Чаще всего в задачах по программированию вершины графа пронумерованы числами от 0 до (n-1), чтобы было удобно обращаться к ним как к индексам в разных массивах.</p>
            <p>В задачах графы чаще всего задаются списком всех ребер, которые нужно считать из ввода. В каком формате оптимально хранить граф? В зависимости от задачи есть несколько способов.</p>
            <h1>Матрица смежности</h1>
            <p>Матрицей смежности называется двумерная матрица G размера n×n, в ячейке [i][j], которой хранится единица, если существует ребро (i, j), и ноль в противном случае.</p>
            <p>Представим данный граф в виде матрицы смежности</p>
            <img src="images/граф.png" alt="" class = "img">
            <table>
                <thead>
                    <tr>
                        <th>&nbsp;</th>
                        <th>1</th>
                        <th>2</th>
                        <th>3</th>
                        <th>4</th>
                        <th>5</th>
                        <th>6</th>
                    </tr>
                </thead>
                <tbody>
                <tr>
                    <td>
                        <strong>1</strong>
                    </td>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>
                        <strong>2</strong>
                    </td>
                    <td>1</td>
                    <td>0</td>
                    <td>1</td>
                    <td>1</td>
                    <td>0</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>
                        <strong>3</strong>
                    </td>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>
                        <strong>4</strong>
                    </td>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>
                        <strong>5</strong>
                    </td>
                    <td>1</td>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>
                        <strong>6</strong>
                    </td>
                    <td>1</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                </tr>
            </tbody>
        </table>
        <pre>
            <code data-lang="cpp">
                #include &lt;iostream&gt;
                #include &lt;vector&gt;

                using namespace std;

                int main()
                {
                   int n,m; // количество вершин, и ребер
                   cin>>n>>m;
                   vector <vector < int > > arr(n,vector < int >(n));
                   for(int i = 0;i < m;i++)
                   {
                       int x,y; // вершины, которые соеденены с собой 
                       cin>>x>>y;
                       arr[x-1][y-1] = 1;
                       arr[y-1][x-1] = 1;
                   }
                   // вывод матрицы
                   for(int i = 0; i < n;i++)
                   {
                       for(int j = 0; j < n; j++)
                       {
                           cout << arr[i][j] <<" ";
                       }
                       cout << endl;
                   }
                   
                }
            </code>
        </pre>
        <h1>Список смежности</h1>
        <p>Давайте теперь для каждой из nn вершин хранить не булевый массив, а номера всех смежных с ней вершин. Для этого нам потребуется любая динамическая структура, например std::vector в C++.</p>
        <pre>
            <code data-lang="cpp">
                // если на вход идет матрица смежности
                vector< vector < int >> g(n);
                for (int i = 0; i < n; ++i){
                    for (int j = 0;j < n;++j){
                        cin >> a;
                        if (a)
                          g[i].push_back(j);
                    }
                }
                
                // если на вход идет список ребер
                cin >> n >> m;
                vector < vector <int> > g(n);
                for (int i = 0; i < m; ++i){
                  cin >> v1 >> v2;
                  g[v1].push_back(v2);
                  g[v2].push_back(v1);
                } 
            </code>
        </pre>
        <h1>Поиск в глубину</h1>
        <p><bold>Поиском в глубину</bold> (англ. depth-first search, DFS) или эйлеровым обходом называется рекурсивный алгоритм обхода корневого дерева или графа, начинающий в корневой вершине (в случае графа может быть выбрана произвольная вершина) и рекурсивно обходящий весь граф, посещая каждую вершину ровно один раз.</p>
        <pre>
            <code data-lang="cpp"> 
                const int maxn = 1e5;
                bool used[maxn]; // тут будем отмечать посещенные вершины

                void dfs(int v) {
                    used[v] = true;
                    for (int u : g[v])
                        if (!used[u])
                            dfs(u);
                }
            </code>
        </pre>
    </section>
    </div>
    <script src="../подсветка/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>